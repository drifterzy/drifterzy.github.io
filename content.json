{"pages":[{"title":"","text":"联系我Email：1074725704@qq.com","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"c++实现一个复数类","text":"导论c++基于对象的主要关注点在于单一class的设计，可以分为两大类class： 不带指针的class 带指针的class 实现一个复数类（不带指针的class）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#ifndef __COMPLEX__#define __COMPLEX__class complex{public: complex(double r = 0,double i = 0):re(r),im(i){} //无返回类型/使用初值列效率高 complex&amp; operator += (const complex&amp;); //此处也加了const，且传递参数和返回值都是引用 double real() const {return re;} //函数在class body内定义完成，自动成为inline double imag() const {return im;} //const成岩函数不会改变数据内容private: double re,im; friend complex&amp; __doapl(complex*,const complex&amp;);//友元函数可以访问private下的数据成员}//共轭复数inline complex conj(const complex&amp; x){ return complex(real(x),-imag(x));}//返回ostream&amp;，而不是voidostream&amp; operator &lt;&lt; (ostream&amp; os,const complex&amp; x){ return os&lt;&lt;'('&lt;&lt;real(x)&lt;&lt;','&lt;&lt;imag(x)&lt;&lt;')';}//返回引用complex&amp;，说明ths本身就存在，不随函数结束而消失。inline complex&amp; __doapl(complex* ths,const complex&amp; r){ ths-&gt;re += r.re; ths-&gt;im += r.im; return *ths;}//返回reference而不是void是因为：c3+=c2+=c1;inline complex&amp; complex::operator += (const complex&amp; r){ return __doapl(this,r);}//不可以返回引用，因为返回的是个local objectinline complex operator + (const complex&amp; x,const complex&amp; y){ return complex(real(x)+real(y),imag(x)+imag(y));}inline complex operator + (const complex&amp; x,double y){ return complex(real(x)+y,imag(x));}inline complex operator + (double x,const complex&amp; y){ return complex(x+real(y),imag(y));}//同理重载减法，相等，不等//此处代表加号，而不是加法inline complex operator + (const complex&amp; x){ return x;}inline complex operator - (const complex&amp; x){ return complex(-real(x),-imag(x));}#endif //__COMPLEX__ 复数类的设计要点123456789101112131415//1、定义complex c1(2,1);complex c2;//使用默认参数complex();//临时对象，运行到下一行生命就终止complex* p = new complex(4);//2、访问级别cout&lt;&lt;c1.imag();//OKcout&lt;&lt;c1.im;//ERROR//3、不带指针的类通常不用写析构函数//4、常量成员函数const complex c1(2,1);//常量对象/变量只能调用常量成员函数cout&lt;&lt;c1.real();//real()成员函数必须声明为常量否则报错//5、引用//返回值设为引用的前提条件是函数中返回的东西不随函数结束而消失。//6、头文件的防卫式声明","link":"/2020/06/09/c++%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A4%8D%E6%95%B0%E7%B1%BB/"},{"title":"c++转换函数","text":"分数类的实现：123456789101112131415class Fraction{public: Fraction(int num,int den = 1)：m_numerator(num),m_denominator(den){} //转换函数 operator double() const{ return (double)(m_numerator/m_denominator); } //操作符+重载(与转换函数同时定义会造成[Error]ambiguous) Fraction operator+(const Fraction&amp; f){ return Fraction(......); }private: int m_numerator; //分子 int m_denominator; //分母} 转换函数的格式：operator 类型() const 不同写返回类型，通常加上const 分数类的调用： conversion function的应用 Fraction f(3,5); double d = 4+f;//调用operator double()将f转换为double类型 non-explicit-one-argument ctor的应用 Fraction f(3,5); Fraction d2 = f+4;//调用non-explicit ctor将4转换为Fraction(4,1)，然后调用operator+* conversion function 与 non-explicit-one-argument ctor同时定义 Fraction f(3,5); Fraction d2 = f+4;//[Error]ambiguous，既可以将4转化为Fraction，也可以将f转化为double explicit-one-argument ctor定义explicit构造函数 Fraction f(3,5); Fraction d2 = f+4;//[Error]conversion from ‘double’ to ‘Fraction’ requested 1explicit Fraction(int num,int den = 1)：m_numerator(num),m_denominator(den){} 构造函数声明为explicit:在C++中，explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换。 explicit使用注意事项： explicit 关键字只能用于类内部的构造函数声明上。 explicit 关键字作用于单个参数的构造函数。 在C++中，explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换","link":"/2020/06/02/c++%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/"},{"title":"git简单使用","text":"前期准备1、git下载 2、创建SSH key 3、登录github账号添加SSH key 简单上手1、在本地新建一个文件夹用来存放项目 2、打开命令行cd到该地址，git clone 项目名 3、在本地修改文件： 添加文件或目录 删除文件或目录 4、把文件添加到仓库 git add file/directory git rm file/git rm -r directory（同样需要commit和push） 5、使用git status显示还未提交的修改 6、git commit -m “注释”：把文件提交到仓库 7、git push：推送到远程","link":"/2020/06/04/git%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"语言","slug":"语言","link":"/tags/%E8%AF%AD%E8%A8%80/"},{"name":"配置","slug":"配置","link":"/tags/%E9%85%8D%E7%BD%AE/"}],"categories":[{"name":"C++语法学习","slug":"C-语法学习","link":"/categories/C-%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"},{"name":"工具使用","slug":"工具使用","link":"/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"}]}